/* eslint-disable @typescript-eslint/no-explicit-any */
import * as D from "@effect-app/core/Dictionary"

import type { ComputeFlat, UnionToIntersection } from "@effect-app/core/utils"
import { array, prop, props } from "./_schema.js"
import * as MO from "./_schema.js"
import { positiveInt } from "./custom.js"

type AdaptSchema<Props extends MO.PropertyRecord, Key extends keyof Props> = {
  [K in Key]: Props[K]
}

// TODO: adapt error types too; low prio
const adaptedSchema =
  <Props extends MO.PropertyRecord>(properties: Props) =>
  <Key extends keyof Props>(keys: readonly Key[]): AdaptSchema<Props, Key> =>
    D.filterWithIndex_(properties, (key) => keys.includes(key as Key)) as any

// TODO: keep existing fields
export const adaptRes = <Props extends MO.PropertyRecord>(properties: Props) => {
  const adapt = adaptedSchema(properties)
  return <Key extends keyof Props>(keys: readonly Key[]) =>
    props({
      items: prop(array(props(adapt(keys)))),
      // TODO: hide count when not asked for $count. and demand non-opt count, when asked.
      count: MO.optProp(positiveInt)
    })
}

export type Adapted<
  Props extends MO.PropertyRecord,
  Key extends keyof Props
> = /* copy pasted from return type of function */ MO.SchemaProperties<{
  items: MO.Property<
    MO.SchemaDefaultSchema<
      unknown,
      readonly ComputeFlat<
        UnionToIntersection<
          {
            [k in keyof AdaptSchema<Props, Key>]: AdaptSchema<
              Props,
              Key
            >[k] extends MO.AnyProperty ? AdaptSchema<Props, Key>[k]["_optional"] extends "optional" ? {
                  readonly [h in k]?:
                    | MO.ParsedShapeOf<AdaptSchema<Props, Key>[k]["_schema"]>
                    | undefined
                }
              : {
                readonly [h in k]: MO.ParsedShapeOf<
                  AdaptSchema<Props, Key>[k]["_schema"]
                >
              }
              : never
          }[Key]
        >
      >[],
      readonly ComputeFlat<
        UnionToIntersection<
          {
            [k in keyof AdaptSchema<Props, Key>]: AdaptSchema<
              Props,
              Key
            >[k] extends MO.AnyProperty ? AdaptSchema<Props, Key>[k]["_optional"] extends "optional" ? {
                  readonly [h in k]?:
                    | MO.ParsedShapeOf<AdaptSchema<Props, Key>[k]["_schema"]>
                    | undefined
                }
              : {
                readonly [h in k]: MO.ParsedShapeOf<
                  AdaptSchema<Props, Key>[k]["_schema"]
                >
              }
              : never
          }[Key]
        >
      >[],
      readonly ComputeFlat<
        UnionToIntersection<
          {
            [k in keyof AdaptSchema<Props, Key>]: AdaptSchema<
              Props,
              Key
            >[k] extends MO.AnyProperty ? AdaptSchema<Props, Key>[k]["_optional"] extends "optional" ? {
                  readonly [
                    h in AdaptSchema<Props, Key>[k]["_as"] extends Some<any>
                      ? AdaptSchema<Props, Key>[k]["_as"]["value"]
                      : k
                  ]?:
                    | MO.EncodedOf<AdaptSchema<Props, Key>[k]["_schema"]>
                    | undefined
                }
              : {
                readonly [
                  h in AdaptSchema<Props, Key>[k]["_as"] extends Some<any> ? AdaptSchema<Props, Key>[k]["_as"]["value"]
                    : k
                ]: MO.EncodedOf<AdaptSchema<Props, Key>[k]["_schema"]>
              }
              : never
          }[Key]
        >
      >[],
      // eslint-disable-next-line @typescript-eslint/ban-types
      {}
    >,
    "required",
    None<any>,
    None<any>
  >
}>
