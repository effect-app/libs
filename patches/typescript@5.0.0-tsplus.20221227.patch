diff --git a/lib/tsc.js b/lib/tsc.js
index 1ac57a7..37b28c2 100644
--- a/lib/tsc.js
+++ b/lib/tsc.js
@@ -24867,10 +24867,11 @@ var Parser;
   function getTsPlusExternalTypesPaths(fileName2, options) {
     var _a2;
     if (options.configFilePath) {
-      let resolvedPaths = [];
       if (tsPlusResolvedPathsCache.has(options.configFilePath)) {
-        resolvedPaths = tsPlusResolvedPathsCache.get(options.configFilePath);
-      } else if (options.tsPlusTypes) {
+        return tsPlusResolvedPathsCache.get(options.configFilePath);
+      }
+      let resolvedPaths = [];
+      if (options.tsPlusTypes) {
         for (const path of options.tsPlusTypes) {
           if (pathIsRelative(path)) {
             resolvedPaths.push(resolvePath(options.configFilePath.split("/").slice(0, -1).join("/"), path));
@@ -24945,9 +24946,15 @@ var Parser;
     }
   }
   function addTsPlusTagsFromExternalTypes(declaration, jsDocNode) {
-    var _a2;
+    var _a2, _b, _c, _d;
     if (currentTsPlusTypes !== null) {
       if (declaration.name && declaration.name.kind === 79 /* Identifier */) {
+        if (!jsDocNode) {
+          jsDocNode = declaration;
+        }
+        if ((_c = (_b = (_a2 = jsDocNode.jsDoc) == null ? void 0 : _a2[0]) == null ? void 0 : _b.tags) == null ? void 0 : _c.find((tag) => tag.tagName.escapedText === "tsplus")) {
+          return;
+        }
         const extensions = currentTsPlusTypes.filter(
           (type) => (declaration.kind === 257 /* VariableDeclaration */ ? type.definitionKind === "const" : declaration.kind === 259 /* FunctionDeclaration */ ? type.definitionKind === "function" : declaration.kind === 261 /* InterfaceDeclaration */ ? type.definitionKind === "interface" : declaration.kind === 260 /* ClassDeclaration */ ? type.definitionKind === "class" : declaration.kind === 262 /* TypeAliasDeclaration */ ? type.definitionKind === "type" : false) && type.definitionName === declaration.name.escapedText.toString()
         ).flatMap((definition) => definition.extensions);
@@ -24961,11 +24968,8 @@ var Parser;
           newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), comment));
         }
         newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), `location "${currentTsPlusFile}"`));
-        if (!jsDocNode) {
-          jsDocNode = declaration;
-        }
         if (jsDocNode.jsDoc && jsDocNode.jsDoc[0]) {
-          const jsDocTags = factory2.createNodeArray(Array.from((_a2 = jsDocNode.jsDoc[0].tags) != null ? _a2 : []).concat(newTags));
+          const jsDocTags = factory2.createNodeArray(Array.from((_d = jsDocNode.jsDoc[0].tags) != null ? _d : []).concat(newTags));
           jsDocNode.jsDoc[0].tags = jsDocTags;
         } else {
           jsDocNode.jsDoc = [factory2.createJSDocComment(void 0, newTags)];
@@ -39960,7 +39964,8 @@ function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory,
       for (const key of getOwnKeys(exports)) {
         if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
           const subTarget = exports[key];
-          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+          const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
           if (result) {
             return result;
           }
@@ -40032,7 +40037,7 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
     return void 0;
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
   const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
   return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
   function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -45910,6 +45915,16 @@ function createTypeChecker(host) {
       }
       return top;
     }
+    function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+      let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+      if (specifier && specifier.indexOf("/node_modules/") > 0) {
+        const r = tryGetImportLocation(fileMap.map, specifier);
+        if (r) {
+          specifier = r;
+        }
+      }
+      return specifier;
+    }
     function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
       var _a2;
       let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -45984,7 +45999,7 @@ function createTypeChecker(host) {
         let assertion;
         if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
           if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
             assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
               factory.createAssertEntry(
                 factory.createStringLiteral("resolution-mode"),
@@ -45995,7 +46010,7 @@ function createTypeChecker(host) {
           }
         }
         if (!specifier) {
-          specifier = getSpecifierForModuleSymbol(chain[0], context);
+          specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
         }
         if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
           const oldSpecifier = specifier;
@@ -80977,13 +80992,27 @@ function getOriginalNodeId(node) {
   node = getOriginalNode(node);
   return node ? getNodeId(node) : 0;
 }
-function getImportLocation(fileMap, source) {
+var importLocationCache = {};
+function tryGetImportLocation(fileMap, source) {
+  if (source in importLocationCache) {
+    return importLocationCache[source];
+  }
   for (const [path, reg] of fileMap) {
     if (source.match(reg)) {
-      return source.replace(reg, path);
+      const r = source.replace(reg, path);
+      importLocationCache[source] = r;
+      return r;
     }
   }
-  throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  importLocationCache[source] = void 0;
+  return void 0;
+}
+function getImportLocation(fileMap, source) {
+  const found = tryGetImportLocation(fileMap, source);
+  if (!found) {
+    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  }
+  return found;
 }
 function getTraceLocation(traceMap, source) {
   for (const [path, reg] of traceMap) {
diff --git a/lib/tsserver.js b/lib/tsserver.js
index 7d407f6..cac4d9f 100644
--- a/lib/tsserver.js
+++ b/lib/tsserver.js
@@ -2384,6 +2384,7 @@ __export(server_exports, {
   tryGetDirectories: () => tryGetDirectories,
   tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
   tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+  tryGetImportLocation: () => tryGetImportLocation,
   tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
   tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
@@ -29150,10 +29151,11 @@ var Parser;
   function getTsPlusExternalTypesPaths(fileName2, options) {
     var _a2;
     if (options.configFilePath) {
-      let resolvedPaths = [];
       if (tsPlusResolvedPathsCache.has(options.configFilePath)) {
-        resolvedPaths = tsPlusResolvedPathsCache.get(options.configFilePath);
-      } else if (options.tsPlusTypes) {
+        return tsPlusResolvedPathsCache.get(options.configFilePath);
+      }
+      let resolvedPaths = [];
+      if (options.tsPlusTypes) {
         for (const path of options.tsPlusTypes) {
           if (pathIsRelative(path)) {
             resolvedPaths.push(resolvePath(options.configFilePath.split("/").slice(0, -1).join("/"), path));
@@ -29228,9 +29230,15 @@ var Parser;
     }
   }
   function addTsPlusTagsFromExternalTypes(declaration, jsDocNode) {
-    var _a2;
+    var _a2, _b, _c, _d;
     if (currentTsPlusTypes !== null) {
       if (declaration.name && declaration.name.kind === 79 /* Identifier */) {
+        if (!jsDocNode) {
+          jsDocNode = declaration;
+        }
+        if ((_c = (_b = (_a2 = jsDocNode.jsDoc) == null ? void 0 : _a2[0]) == null ? void 0 : _b.tags) == null ? void 0 : _c.find((tag) => tag.tagName.escapedText === "tsplus")) {
+          return;
+        }
         const extensions = currentTsPlusTypes.filter(
           (type) => (declaration.kind === 257 /* VariableDeclaration */ ? type.definitionKind === "const" : declaration.kind === 259 /* FunctionDeclaration */ ? type.definitionKind === "function" : declaration.kind === 261 /* InterfaceDeclaration */ ? type.definitionKind === "interface" : declaration.kind === 260 /* ClassDeclaration */ ? type.definitionKind === "class" : declaration.kind === 262 /* TypeAliasDeclaration */ ? type.definitionKind === "type" : false) && type.definitionName === declaration.name.escapedText.toString()
         ).flatMap((definition) => definition.extensions);
@@ -29244,11 +29252,8 @@ var Parser;
           newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), comment));
         }
         newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), `location "${currentTsPlusFile}"`));
-        if (!jsDocNode) {
-          jsDocNode = declaration;
-        }
         if (jsDocNode.jsDoc && jsDocNode.jsDoc[0]) {
-          const jsDocTags = factory2.createNodeArray(Array.from((_a2 = jsDocNode.jsDoc[0].tags) != null ? _a2 : []).concat(newTags));
+          const jsDocTags = factory2.createNodeArray(Array.from((_d = jsDocNode.jsDoc[0].tags) != null ? _d : []).concat(newTags));
           jsDocNode.jsDoc[0].tags = jsDocTags;
         } else {
           jsDocNode.jsDoc = [factory2.createJSDocComment(void 0, newTags)];
@@ -44391,7 +44396,8 @@ function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory,
       for (const key of getOwnKeys(exports)) {
         if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
           const subTarget = exports[key];
-          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+          const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
           if (result) {
             return result;
           }
@@ -44463,7 +44469,7 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
     return void 0;
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
   const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
   return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
   function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -50341,6 +50347,16 @@ function createTypeChecker(host) {
       }
       return top;
     }
+    function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+      let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+      if (specifier && specifier.indexOf("/node_modules/") > 0) {
+        const r = tryGetImportLocation(fileMap.map, specifier);
+        if (r) {
+          specifier = r;
+        }
+      }
+      return specifier;
+    }
     function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
       var _a2;
       let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -50415,7 +50431,7 @@ function createTypeChecker(host) {
         let assertion;
         if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
           if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
             assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
               factory.createAssertEntry(
                 factory.createStringLiteral("resolution-mode"),
@@ -50426,7 +50442,7 @@ function createTypeChecker(host) {
           }
         }
         if (!specifier) {
-          specifier = getSpecifierForModuleSymbol(chain[0], context);
+          specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
         }
         if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
           const oldSpecifier = specifier;
@@ -85622,13 +85638,27 @@ function getOriginalNodeId(node) {
   node = getOriginalNode(node);
   return node ? getNodeId(node) : 0;
 }
-function getImportLocation(fileMap, source) {
+var importLocationCache = {};
+function tryGetImportLocation(fileMap, source) {
+  if (source in importLocationCache) {
+    return importLocationCache[source];
+  }
   for (const [path, reg] of fileMap) {
     if (source.match(reg)) {
-      return source.replace(reg, path);
+      const r = source.replace(reg, path);
+      importLocationCache[source] = r;
+      return r;
     }
   }
-  throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  importLocationCache[source] = void 0;
+  return void 0;
+}
+function getImportLocation(fileMap, source) {
+  const found = tryGetImportLocation(fileMap, source);
+  if (!found) {
+    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  }
+  return found;
 }
 function getTraceLocation(traceMap, source) {
   for (const [path, reg] of traceMap) {
@@ -121712,6 +121742,7 @@ __export(ts_exports3, {
   tryGetDirectories: () => tryGetDirectories,
   tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
   tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+  tryGetImportLocation: () => tryGetImportLocation,
   tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
   tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
@@ -173023,6 +173054,7 @@ start(initializeNodeSystem(), require("os").platform());
   tryGetDirectories,
   tryGetExtensionFromPath,
   tryGetImportFromModuleSpecifier,
+  tryGetImportLocation,
   tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration,
   tryGetNativePerformanceHooks,
diff --git a/lib/tsserverlibrary.d.ts b/lib/tsserverlibrary.d.ts
index 663097f..95571ff 100644
--- a/lib/tsserverlibrary.d.ts
+++ b/lib/tsserverlibrary.d.ts
@@ -9908,6 +9908,10 @@ declare namespace ts {
      * @param context A lexical environment context for the visitor.
      */
     function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    function tryGetImportLocation(fileMap: [
+        string,
+        RegExp
+    ][], source: string): string | undefined;
     function getImportLocation(fileMap: [
         string,
         RegExp
diff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js
index 7d63e87..dacc8de 100644
--- a/lib/tsserverlibrary.js
+++ b/lib/tsserverlibrary.js
@@ -26870,10 +26870,11 @@ ${lanes.join("\n")}
         function getTsPlusExternalTypesPaths(fileName2, options) {
           var _a2;
           if (options.configFilePath) {
-            let resolvedPaths = [];
             if (tsPlusResolvedPathsCache.has(options.configFilePath)) {
-              resolvedPaths = tsPlusResolvedPathsCache.get(options.configFilePath);
-            } else if (options.tsPlusTypes) {
+              return tsPlusResolvedPathsCache.get(options.configFilePath);
+            }
+            let resolvedPaths = [];
+            if (options.tsPlusTypes) {
               for (const path of options.tsPlusTypes) {
                 if (pathIsRelative(path)) {
                   resolvedPaths.push(resolvePath(options.configFilePath.split("/").slice(0, -1).join("/"), path));
@@ -26948,9 +26949,15 @@ ${lanes.join("\n")}
           }
         }
         function addTsPlusTagsFromExternalTypes(declaration, jsDocNode) {
-          var _a2;
+          var _a2, _b, _c, _d;
           if (currentTsPlusTypes !== null) {
             if (declaration.name && declaration.name.kind === 79 /* Identifier */) {
+              if (!jsDocNode) {
+                jsDocNode = declaration;
+              }
+              if ((_c = (_b = (_a2 = jsDocNode.jsDoc) == null ? void 0 : _a2[0]) == null ? void 0 : _b.tags) == null ? void 0 : _c.find((tag) => tag.tagName.escapedText === "tsplus")) {
+                return;
+              }
               const extensions = currentTsPlusTypes.filter(
                 (type) => (declaration.kind === 257 /* VariableDeclaration */ ? type.definitionKind === "const" : declaration.kind === 259 /* FunctionDeclaration */ ? type.definitionKind === "function" : declaration.kind === 261 /* InterfaceDeclaration */ ? type.definitionKind === "interface" : declaration.kind === 260 /* ClassDeclaration */ ? type.definitionKind === "class" : declaration.kind === 262 /* TypeAliasDeclaration */ ? type.definitionKind === "type" : false) && type.definitionName === declaration.name.escapedText.toString()
               ).flatMap((definition) => definition.extensions);
@@ -26964,11 +26971,8 @@ ${lanes.join("\n")}
                 newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), comment));
               }
               newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), `location "${currentTsPlusFile}"`));
-              if (!jsDocNode) {
-                jsDocNode = declaration;
-              }
               if (jsDocNode.jsDoc && jsDocNode.jsDoc[0]) {
-                const jsDocTags = factory2.createNodeArray(Array.from((_a2 = jsDocNode.jsDoc[0].tags) != null ? _a2 : []).concat(newTags));
+                const jsDocTags = factory2.createNodeArray(Array.from((_d = jsDocNode.jsDoc[0].tags) != null ? _d : []).concat(newTags));
                 jsDocNode.jsDoc[0].tags = jsDocTags;
               } else {
                 jsDocNode.jsDoc = [factory2.createJSDocComment(void 0, newTags)];
@@ -41908,7 +41912,8 @@ ${lanes.join("\n")}
         for (const key of getOwnKeys(exports)) {
           if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
             const subTarget = exports[key];
-            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+            const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
             if (result) {
               return result;
             }
@@ -41980,7 +41985,7 @@ ${lanes.join("\n")}
     if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
       return void 0;
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
     const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
     return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
     function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -47734,6 +47739,16 @@ ${lanes.join("\n")}
         }
         return top;
       }
+      function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+        let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+        if (specifier && specifier.indexOf("/node_modules/") > 0) {
+          const r = tryGetImportLocation(fileMap.map, specifier);
+          if (r) {
+            specifier = r;
+          }
+        }
+        return specifier;
+      }
       function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
         var _a2;
         let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -47808,7 +47823,7 @@ ${lanes.join("\n")}
           let assertion;
           if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
             if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-              specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+              specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
               assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
                 factory.createAssertEntry(
                   factory.createStringLiteral("resolution-mode"),
@@ -47819,7 +47834,7 @@ ${lanes.join("\n")}
             }
           }
           if (!specifier) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
           }
           if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
             const oldSpecifier = specifier;
@@ -83189,13 +83204,26 @@ ${lanes.join("\n")}
     node = getOriginalNode(node);
     return node ? getNodeId(node) : 0;
   }
-  function getImportLocation(fileMap, source) {
+  function tryGetImportLocation(fileMap, source) {
+    if (source in importLocationCache) {
+      return importLocationCache[source];
+    }
     for (const [path, reg] of fileMap) {
       if (source.match(reg)) {
-        return source.replace(reg, path);
+        const r = source.replace(reg, path);
+        importLocationCache[source] = r;
+        return r;
       }
     }
-    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    importLocationCache[source] = void 0;
+    return void 0;
+  }
+  function getImportLocation(fileMap, source) {
+    const found = tryGetImportLocation(fileMap, source);
+    if (!found) {
+      throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    }
+    return found;
   }
   function getTraceLocation(traceMap, source) {
     for (const [path, reg] of traceMap) {
@@ -83604,10 +83632,12 @@ ${lanes.join("\n")}
     }
     return { decorators };
   }
+  var importLocationCache;
   var init_utilities3 = __esm({
     "src/compiler/transformers/utilities.ts"() {
       "use strict";
       init_ts2();
+      importLocationCache = {};
     }
   });
 
@@ -169149,6 +169179,7 @@ ${e.message}`;
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
     tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
@@ -171813,6 +171844,7 @@ ${e.message}`;
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
     tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
diff --git a/lib/typescript.d.ts b/lib/typescript.d.ts
index 0efd888..a6b5088 100644
--- a/lib/typescript.d.ts
+++ b/lib/typescript.d.ts
@@ -5972,6 +5972,10 @@ declare namespace ts {
      * @param context A lexical environment context for the visitor.
      */
     function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    function tryGetImportLocation(fileMap: [
+        string,
+        RegExp
+    ][], source: string): string | undefined;
     function getImportLocation(fileMap: [
         string,
         RegExp
diff --git a/lib/typescript.js b/lib/typescript.js
index b94ffd8..2666cb7 100644
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -26870,10 +26870,11 @@ ${lanes.join("\n")}
         function getTsPlusExternalTypesPaths(fileName2, options) {
           var _a2;
           if (options.configFilePath) {
-            let resolvedPaths = [];
             if (tsPlusResolvedPathsCache.has(options.configFilePath)) {
-              resolvedPaths = tsPlusResolvedPathsCache.get(options.configFilePath);
-            } else if (options.tsPlusTypes) {
+              return tsPlusResolvedPathsCache.get(options.configFilePath);
+            }
+            let resolvedPaths = [];
+            if (options.tsPlusTypes) {
               for (const path of options.tsPlusTypes) {
                 if (pathIsRelative(path)) {
                   resolvedPaths.push(resolvePath(options.configFilePath.split("/").slice(0, -1).join("/"), path));
@@ -26948,9 +26949,15 @@ ${lanes.join("\n")}
           }
         }
         function addTsPlusTagsFromExternalTypes(declaration, jsDocNode) {
-          var _a2;
+          var _a2, _b, _c, _d;
           if (currentTsPlusTypes !== null) {
             if (declaration.name && declaration.name.kind === 79 /* Identifier */) {
+              if (!jsDocNode) {
+                jsDocNode = declaration;
+              }
+              if ((_c = (_b = (_a2 = jsDocNode.jsDoc) == null ? void 0 : _a2[0]) == null ? void 0 : _b.tags) == null ? void 0 : _c.find((tag) => tag.tagName.escapedText === "tsplus")) {
+                return;
+              }
               const extensions = currentTsPlusTypes.filter(
                 (type) => (declaration.kind === 257 /* VariableDeclaration */ ? type.definitionKind === "const" : declaration.kind === 259 /* FunctionDeclaration */ ? type.definitionKind === "function" : declaration.kind === 261 /* InterfaceDeclaration */ ? type.definitionKind === "interface" : declaration.kind === 260 /* ClassDeclaration */ ? type.definitionKind === "class" : declaration.kind === 262 /* TypeAliasDeclaration */ ? type.definitionKind === "type" : false) && type.definitionName === declaration.name.escapedText.toString()
               ).flatMap((definition) => definition.extensions);
@@ -26964,11 +26971,8 @@ ${lanes.join("\n")}
                 newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), comment));
               }
               newTags.push(factory2.createJSDocUnknownTag(factory2.createIdentifier("tsplus"), `location "${currentTsPlusFile}"`));
-              if (!jsDocNode) {
-                jsDocNode = declaration;
-              }
               if (jsDocNode.jsDoc && jsDocNode.jsDoc[0]) {
-                const jsDocTags = factory2.createNodeArray(Array.from((_a2 = jsDocNode.jsDoc[0].tags) != null ? _a2 : []).concat(newTags));
+                const jsDocTags = factory2.createNodeArray(Array.from((_d = jsDocNode.jsDoc[0].tags) != null ? _d : []).concat(newTags));
                 jsDocNode.jsDoc[0].tags = jsDocTags;
               } else {
                 jsDocNode.jsDoc = [factory2.createJSDocComment(void 0, newTags)];
@@ -41908,7 +41912,8 @@ ${lanes.join("\n")}
         for (const key of getOwnKeys(exports)) {
           if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
             const subTarget = exports[key];
-            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+            const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 /* Directory */ : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
             if (result) {
               return result;
             }
@@ -41980,7 +41985,7 @@ ${lanes.join("\n")}
     if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
       return void 0;
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
     const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
     return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
     function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -47734,6 +47739,16 @@ ${lanes.join("\n")}
         }
         return top;
       }
+      function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+        let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+        if (specifier && specifier.indexOf("/node_modules/") > 0) {
+          const r = tryGetImportLocation(fileMap.map, specifier);
+          if (r) {
+            specifier = r;
+          }
+        }
+        return specifier;
+      }
       function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
         var _a2;
         let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -47808,7 +47823,7 @@ ${lanes.join("\n")}
           let assertion;
           if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
             if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-              specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+              specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
               assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
                 factory.createAssertEntry(
                   factory.createStringLiteral("resolution-mode"),
@@ -47819,7 +47834,7 @@ ${lanes.join("\n")}
             }
           }
           if (!specifier) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
           }
           if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
             const oldSpecifier = specifier;
@@ -83189,13 +83204,26 @@ ${lanes.join("\n")}
     node = getOriginalNode(node);
     return node ? getNodeId(node) : 0;
   }
-  function getImportLocation(fileMap, source) {
+  function tryGetImportLocation(fileMap, source) {
+    if (source in importLocationCache) {
+      return importLocationCache[source];
+    }
     for (const [path, reg] of fileMap) {
       if (source.match(reg)) {
-        return source.replace(reg, path);
+        const r = source.replace(reg, path);
+        importLocationCache[source] = r;
+        return r;
       }
     }
-    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    importLocationCache[source] = void 0;
+    return void 0;
+  }
+  function getImportLocation(fileMap, source) {
+    const found = tryGetImportLocation(fileMap, source);
+    if (!found) {
+      throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    }
+    return found;
   }
   function getTraceLocation(traceMap, source) {
     for (const [path, reg] of traceMap) {
@@ -83604,10 +83632,12 @@ ${lanes.join("\n")}
     }
     return { decorators };
   }
+  var importLocationCache;
   var init_utilities3 = __esm({
     "src/compiler/transformers/utilities.ts"() {
       "use strict";
       init_ts2();
+      importLocationCache = {};
     }
   });
 
@@ -159525,6 +159555,7 @@ ${options.prefix}` : "\n" : options.prefix
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
     tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
