diff --git a/lib/tsc.js b/lib/tsc.js
index 6e314d7..491e88d 100644
--- a/lib/tsc.js
+++ b/lib/tsc.js
@@ -24630,6 +24630,10 @@ function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks
   newSourceFile.flags |= sourceFile.flags & 6291456 /* PermanentlySetIncrementalFlags */;
   return newSourceFile;
 }
+const tsPlusTypeCache = {}
+const resolvedPathsCache = {}
+const resolvedModuleCache = {}
+
 var Parser;
 ((Parser2) => {
   const scanner2 = createScanner(99 /* Latest */, true);
@@ -24862,16 +24866,15 @@ var Parser;
       parseDiagnostics.push(createDetachedDiagnostic(fileName, pos, end, diagnostic));
     }
   }
-  function parseTsPlusExternalTypes(fileName2, options) {
-    if (options.configFilePath) {
-      let resolvedPaths = [];
+  function getResolvedPaths(options) {
+    if (options.configFilePath in resolvedPathsCache) { return resolvedPathsCache[options.configFilePath] }
+    let resolvedPaths = [];
       if (options.tsPlusTypes) {
         for (const path of options.tsPlusTypes) {
           if (pathIsRelative(path)) {
             resolvedPaths.push(resolvePath(options.configFilePath.split("/").slice(0, -1).join("/"), path));
           } else {
-            let resolvedModule = resolveModuleName(path, options.configFilePath, options, sys).resolvedModule;
-            resolvedModule != null ? resolvedModule : resolvedModule = resolveModuleName(path, fileName2, options, sys).resolvedModule;
+            const resolvedModule = resolveModuleName(path, options.configFilePath, options, sys).resolvedModule;
             if (resolvedModule) {
               resolvedPaths.push(resolvedModule.resolvedFileName);
               break;
@@ -24879,7 +24882,7 @@ var Parser;
           }
         }
       }
-      const packagePath = removeExtension(fileName2.split("node_modules").slice(-1)[0].substring(1), ".d.ts");
+      const packagePath = removeExtension(options.configFilePath.split("node_modules").slice(-1)[0].substring(1), ".d.ts");
       if (packagePath) {
         let packageName;
         if (packagePath.startsWith("@")) {
@@ -24909,16 +24912,21 @@ var Parser;
           resolvedPaths.push(resolvedModule.resolvedFileName);
         }
       }
+      resolvedPathsCache[options.configFilePath] = resolvedPaths
+      return resolvedPaths
+  }
+  function parseTsPlusExternalTypes(fileName2, options) {
+    if (options.configFilePath) {
+      const resolvedPaths = getResolvedPaths(options)
       if (resolvedPaths.length === 0) {
         return;
       }
       for (const resolvedPath of resolvedPaths) {
-        const text = sys.readFile(resolvedPath);
-        if (text) {
-          const json = JSON.parse(text);
+        const json = resolvedPath in tsPlusTypeCache ? tsPlusTypeCache[resolvedPath] : (() => { const text = sys.readFile(resolvedPath); if (text) { const json = JSON.parse(text); tsPlusTypeCache[resolvedPath] = json; return json}})()
+        if (json) {
           for (const moduleName in json) {
-            let resolvedModule = resolveModuleName(moduleName, resolvedPath, options, sys).resolvedModule;
-            resolvedModule != null ? resolvedModule : resolvedModule = resolveModuleName(moduleName, fileName2, options, sys).resolvedModule;
+            const key = `${options.configFilePath}+${moduleName}`
+            const resolvedModule = key in resolvedModuleCache ? resolvedModuleCache[key] : (resolvedModuleCache[key] = resolveModuleName(moduleName, options.configFilePath, options, sys).resolvedModule);
             if (resolvedModule && resolvedModule.resolvedFileName === fileName2) {
               currentTsPlusTypes = json[moduleName];
               currentTsPlusFile = moduleName;
@@ -39945,7 +39953,8 @@ function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory,
       for (const key of getOwnKeys(exports)) {
         if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
           const subTarget = exports[key];
-          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+          const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
           if (result) {
             return result;
           }
@@ -40017,7 +40026,7 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
     return void 0;
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
   const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
   return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
   function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -45888,6 +45897,16 @@ function createTypeChecker(host) {
       }
       return top;
     }
+    function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+      let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+      if (specifier && specifier.indexOf("/node_modules/") > 0) {
+        const r = tryGetImportLocation(fileMap.map, specifier);
+        if (r) {
+          specifier = r;
+        }
+      }
+      return specifier;
+    }
     function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
       var _a2;
       let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -45962,7 +45981,7 @@ function createTypeChecker(host) {
         let assertion;
         if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
           if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
             assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
               factory.createAssertEntry(
                 factory.createStringLiteral("resolution-mode"),
@@ -45973,7 +45992,7 @@ function createTypeChecker(host) {
           }
         }
         if (!specifier) {
-          specifier = getSpecifierForModuleSymbol(chain[0], context);
+          specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
         }
         if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
           const oldSpecifier = specifier;
@@ -80955,13 +80974,27 @@ function getOriginalNodeId(node) {
   node = getOriginalNode(node);
   return node ? getNodeId(node) : 0;
 }
-function getImportLocation(fileMap, source) {
+var importLocationCache = {};
+function tryGetImportLocation(fileMap, source) {
+  if (source in importLocationCache) {
+    return importLocationCache[source];
+  }
   for (const [path, reg] of fileMap) {
     if (source.match(reg)) {
-      return source.replace(reg, path);
+      const r = source.replace(reg, path);
+      importLocationCache[source] = r;
+      return r;
     }
   }
-  throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  importLocationCache[source] = void 0;
+  return void 0;
+}
+function getImportLocation(fileMap, source) {
+  const found = tryGetImportLocation(fileMap, source);
+  if (!found) {
+    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  }
+  return found;
 }
 function getTraceLocation(traceMap, source) {
   for (const [path, reg] of traceMap) {
diff --git a/lib/tsserver.js b/lib/tsserver.js
index 08495cd..dd49fe3 100644
--- a/lib/tsserver.js
+++ b/lib/tsserver.js
@@ -2384,6 +2384,7 @@ __export(server_exports, {
   tryGetDirectories: () => tryGetDirectories,
   tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
   tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+  tryGetImportLocation: () => tryGetImportLocation,
   tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
   tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
@@ -28913,6 +28914,10 @@ function parseIsolatedJSDocComment(content, start2, length2) {
 function parseJSDocTypeExpressionForTests(content, start2, length2) {
   return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start2, length2);
 }
+const tsPlusTypeCache = {}
+const resolvedPathsCache = {}
+const resolvedModuleCache = {}
+
 var Parser;
 ((Parser2) => {
   const scanner2 = createScanner(99 /* Latest */, true);
@@ -29145,16 +29150,15 @@ var Parser;
       parseDiagnostics.push(createDetachedDiagnostic(fileName, pos, end, diagnostic));
     }
   }
-  function parseTsPlusExternalTypes(fileName2, options) {
-    if (options.configFilePath) {
-      let resolvedPaths = [];
+  function getResolvedPaths(options) {
+    if (options.configFilePath in resolvedPathsCache) { return resolvedPathsCache[options.configFilePath] }
+    let resolvedPaths = [];
       if (options.tsPlusTypes) {
         for (const path of options.tsPlusTypes) {
           if (pathIsRelative(path)) {
             resolvedPaths.push(resolvePath(options.configFilePath.split("/").slice(0, -1).join("/"), path));
           } else {
-            let resolvedModule = resolveModuleName(path, options.configFilePath, options, sys).resolvedModule;
-            resolvedModule != null ? resolvedModule : resolvedModule = resolveModuleName(path, fileName2, options, sys).resolvedModule;
+            const resolvedModule = resolveModuleName(path, options.configFilePath, options, sys).resolvedModule;
             if (resolvedModule) {
               resolvedPaths.push(resolvedModule.resolvedFileName);
               break;
@@ -29162,7 +29166,7 @@ var Parser;
           }
         }
       }
-      const packagePath = removeExtension(fileName2.split("node_modules").slice(-1)[0].substring(1), ".d.ts");
+      const packagePath = removeExtension(options.configFilePath.split("node_modules").slice(-1)[0].substring(1), ".d.ts");
       if (packagePath) {
         let packageName;
         if (packagePath.startsWith("@")) {
@@ -29192,16 +29196,21 @@ var Parser;
           resolvedPaths.push(resolvedModule.resolvedFileName);
         }
       }
+      resolvedPathsCache[options.configFilePath] = resolvedPaths
+      return resolvedPaths
+  }
+  function parseTsPlusExternalTypes(fileName2, options) {
+    if (options.configFilePath) {
+      const resolvedPaths = getResolvedPaths(options)
       if (resolvedPaths.length === 0) {
         return;
       }
       for (const resolvedPath of resolvedPaths) {
-        const text = sys.readFile(resolvedPath);
-        if (text) {
-          const json = JSON.parse(text);
+        const json = resolvedPath in tsPlusTypeCache ? tsPlusTypeCache[resolvedPath] : (() => { const text = sys.readFile(resolvedPath); if (text) { const json = JSON.parse(text); tsPlusTypeCache[resolvedPath] = json; return json}})()
+        if (json) {
           for (const moduleName in json) {
-            let resolvedModule = resolveModuleName(moduleName, resolvedPath, options, sys).resolvedModule;
-            resolvedModule != null ? resolvedModule : resolvedModule = resolveModuleName(moduleName, fileName2, options, sys).resolvedModule;
+            const key = `${options.configFilePath}+${moduleName}`
+            const resolvedModule = key in resolvedModuleCache ? resolvedModuleCache[key] : (resolvedModuleCache[key] = resolveModuleName(moduleName, options.configFilePath, options, sys).resolvedModule);
             if (resolvedModule && resolvedModule.resolvedFileName === fileName2) {
               currentTsPlusTypes = json[moduleName];
               currentTsPlusFile = moduleName;
@@ -44376,7 +44385,8 @@ function tryGetModuleNameFromExports(options, targetFilePath, packageDirectory,
       for (const key of getOwnKeys(exports)) {
         if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
           const subTarget = exports[key];
-          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+          const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+          const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
           if (result) {
             return result;
           }
@@ -44448,7 +44458,7 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
     return void 0;
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
   const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
   return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
   function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -50319,6 +50329,16 @@ function createTypeChecker(host) {
       }
       return top;
     }
+    function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+      let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+      if (specifier && specifier.indexOf("/node_modules/") > 0) {
+        const r = tryGetImportLocation(fileMap.map, specifier);
+        if (r) {
+          specifier = r;
+        }
+      }
+      return specifier;
+    }
     function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
       var _a2;
       let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -50393,7 +50413,7 @@ function createTypeChecker(host) {
         let assertion;
         if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
           if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
             assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
               factory.createAssertEntry(
                 factory.createStringLiteral("resolution-mode"),
@@ -50404,7 +50424,7 @@ function createTypeChecker(host) {
           }
         }
         if (!specifier) {
-          specifier = getSpecifierForModuleSymbol(chain[0], context);
+          specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
         }
         if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
           const oldSpecifier = specifier;
@@ -85600,13 +85620,27 @@ function getOriginalNodeId(node) {
   node = getOriginalNode(node);
   return node ? getNodeId(node) : 0;
 }
-function getImportLocation(fileMap, source) {
+var importLocationCache = {};
+function tryGetImportLocation(fileMap, source) {
+  if (source in importLocationCache) {
+    return importLocationCache[source];
+  }
   for (const [path, reg] of fileMap) {
     if (source.match(reg)) {
-      return source.replace(reg, path);
+      const r = source.replace(reg, path);
+      importLocationCache[source] = r;
+      return r;
     }
   }
-  throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  importLocationCache[source] = void 0;
+  return void 0;
+}
+function getImportLocation(fileMap, source) {
+  const found = tryGetImportLocation(fileMap, source);
+  if (!found) {
+    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+  }
+  return found;
 }
 function getTraceLocation(traceMap, source) {
   for (const [path, reg] of traceMap) {
@@ -121690,6 +121724,7 @@ __export(ts_exports3, {
   tryGetDirectories: () => tryGetDirectories,
   tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
   tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+  tryGetImportLocation: () => tryGetImportLocation,
   tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
   tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
@@ -173001,6 +173036,7 @@ start(initializeNodeSystem(), require("os").platform());
   tryGetDirectories,
   tryGetExtensionFromPath,
   tryGetImportFromModuleSpecifier,
+  tryGetImportLocation,
   tryGetModuleNameFromFile,
   tryGetModuleSpecifierFromDeclaration,
   tryGetNativePerformanceHooks,
diff --git a/lib/tsserverlibrary.d.ts b/lib/tsserverlibrary.d.ts
index 663097f..95571ff 100644
--- a/lib/tsserverlibrary.d.ts
+++ b/lib/tsserverlibrary.d.ts
@@ -9908,6 +9908,10 @@ declare namespace ts {
      * @param context A lexical environment context for the visitor.
      */
     function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    function tryGetImportLocation(fileMap: [
+        string,
+        RegExp
+    ][], source: string): string | undefined;
     function getImportLocation(fileMap: [
         string,
         RegExp
diff --git a/lib/tsserverlibrary.js b/lib/tsserverlibrary.js
index a7efbf3..9b80db7 100644
--- a/lib/tsserverlibrary.js
+++ b/lib/tsserverlibrary.js
@@ -41893,7 +41893,8 @@ ${lanes.join("\n")}
         for (const key of getOwnKeys(exports)) {
           if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
             const subTarget = exports[key];
-            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+            const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
             if (result) {
               return result;
             }
@@ -41965,7 +41966,7 @@ ${lanes.join("\n")}
     if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
       return void 0;
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
     const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
     return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
     function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -47712,6 +47713,16 @@ ${lanes.join("\n")}
         }
         return top;
       }
+      function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+        let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+        if (specifier && specifier.indexOf("/node_modules/") > 0) {
+          const r = tryGetImportLocation(fileMap.map, specifier);
+          if (r) {
+            specifier = r;
+          }
+        }
+        return specifier;
+      }
       function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
         var _a2;
         let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -47786,7 +47797,7 @@ ${lanes.join("\n")}
           let assertion;
           if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
             if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-              specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+              specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
               assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
                 factory.createAssertEntry(
                   factory.createStringLiteral("resolution-mode"),
@@ -47797,7 +47808,7 @@ ${lanes.join("\n")}
             }
           }
           if (!specifier) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
           }
           if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
             const oldSpecifier = specifier;
@@ -83167,13 +83178,26 @@ ${lanes.join("\n")}
     node = getOriginalNode(node);
     return node ? getNodeId(node) : 0;
   }
-  function getImportLocation(fileMap, source) {
+  function tryGetImportLocation(fileMap, source) {
+    if (source in importLocationCache) {
+      return importLocationCache[source];
+    }
     for (const [path, reg] of fileMap) {
       if (source.match(reg)) {
-        return source.replace(reg, path);
+        const r = source.replace(reg, path);
+        importLocationCache[source] = r;
+        return r;
       }
     }
-    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    importLocationCache[source] = void 0;
+    return void 0;
+  }
+  function getImportLocation(fileMap, source) {
+    const found = tryGetImportLocation(fileMap, source);
+    if (!found) {
+      throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    }
+    return found;
   }
   function getTraceLocation(traceMap, source) {
     for (const [path, reg] of traceMap) {
@@ -83582,10 +83606,12 @@ ${lanes.join("\n")}
     }
     return { decorators };
   }
+  var importLocationCache;
   var init_utilities3 = __esm({
     "src/compiler/transformers/utilities.ts"() {
       "use strict";
       init_ts2();
+      importLocationCache = {};
     }
   });
 
@@ -169127,6 +169153,7 @@ ${e.message}`;
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
     tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
@@ -171791,6 +171818,7 @@ ${e.message}`;
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
     tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
diff --git a/lib/typescript.d.ts b/lib/typescript.d.ts
index 0efd888..a6b5088 100644
--- a/lib/typescript.d.ts
+++ b/lib/typescript.d.ts
@@ -5972,6 +5972,10 @@ declare namespace ts {
      * @param context A lexical environment context for the visitor.
      */
     function visitEachChild<T extends Node>(node: T | undefined, visitor: Visitor, context: TransformationContext, nodesVisitor?: typeof visitNodes, tokenVisitor?: Visitor): T | undefined;
+    function tryGetImportLocation(fileMap: [
+        string,
+        RegExp
+    ][], source: string): string | undefined;
     function getImportLocation(fileMap: [
         string,
         RegExp
diff --git a/lib/typescript.js b/lib/typescript.js
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -26199,6 +26199,9 @@ ${lanes.join("\n")}
     return lhs.name.escapedText === rhs.name.escapedText && tagNamesAreEquivalent(lhs.expression, rhs.expression);
   }
   var tsPlusExportedExtensionRegex, NodeConstructor, TokenConstructor, IdentifierConstructor, PrivateIdentifierConstructor, SourceFileConstructor, parseBaseNodeFactory, parseNodeFactory, forEachChildTable, Parser, IncrementalParser, namedArgRegExCache, tripleSlashXMLCommentStartRegEx, singleLinePragmaRegEx;
+  const tsPlusTypeCache = {}
+  const resolvedPathsCache = {}
+  const resolvedModuleCache = {}
   var init_parser = __esm({
     "src/compiler/parser.ts"() {
       "use strict";
@@ -26865,16 +26868,15 @@ ${lanes.join("\n")}
             parseDiagnostics.push(createDetachedDiagnostic(fileName, pos, end, diagnostic));
           }
         }
-        function parseTsPlusExternalTypes(fileName2, options) {
-          if (options.configFilePath) {
-            let resolvedPaths = [];
+        function getResolvedPaths(options) {
+          if (options.configFilePath in resolvedPathsCache) { return resolvedPathsCache[options.configFilePath] }
+          let resolvedPaths = [];
             if (options.tsPlusTypes) {
               for (const path of options.tsPlusTypes) {
                 if (pathIsRelative(path)) {
                   resolvedPaths.push(resolvePath(options.configFilePath.split("/").slice(0, -1).join("/"), path));
                 } else {
-                  let resolvedModule = resolveModuleName(path, options.configFilePath, options, sys).resolvedModule;
-                  resolvedModule != null ? resolvedModule : resolvedModule = resolveModuleName(path, fileName2, options, sys).resolvedModule;
+                  const resolvedModule = resolveModuleName(path, options.configFilePath, options, sys).resolvedModule;
                   if (resolvedModule) {
                     resolvedPaths.push(resolvedModule.resolvedFileName);
                     break;
@@ -26882,7 +26884,7 @@ ${lanes.join("\n")}
                 }
               }
             }
-            const packagePath = removeExtension(fileName2.split("node_modules").slice(-1)[0].substring(1), ".d.ts");
+            const packagePath = removeExtension(options.configFilePath.split("node_modules").slice(-1)[0].substring(1), ".d.ts");
             if (packagePath) {
               let packageName;
               if (packagePath.startsWith("@")) {
@@ -26912,16 +26914,21 @@ ${lanes.join("\n")}
                 resolvedPaths.push(resolvedModule.resolvedFileName);
               }
             }
+            resolvedPathsCache[options.configFilePath] = resolvedPaths
+            return resolvedPaths
+        }
+        function parseTsPlusExternalTypes(fileName2, options) {
+          if (options.configFilePath) {
+            const resolvedPaths = getResolvedPaths(options)
             if (resolvedPaths.length === 0) {
               return;
             }
             for (const resolvedPath of resolvedPaths) {
-              const text = sys.readFile(resolvedPath);
-              if (text) {
-                const json = JSON.parse(text);
+              const json = resolvedPath in tsPlusTypeCache ? tsPlusTypeCache[resolvedPath] : (() => { const text = sys.readFile(resolvedPath); if (text) { const json = JSON.parse(text); tsPlusTypeCache[resolvedPath] = json; return json}})()
+              if (json) {
                 for (const moduleName in json) {
-                  let resolvedModule = resolveModuleName(moduleName, resolvedPath, options, sys).resolvedModule;
-                  resolvedModule != null ? resolvedModule : resolvedModule = resolveModuleName(moduleName, fileName2, options, sys).resolvedModule;
+                  const key = `${options.configFilePath}+${moduleName}`
+                  const resolvedModule = key in resolvedModuleCache ? resolvedModuleCache[key] : (resolvedModuleCache[key] = resolveModuleName(moduleName, options.configFilePath, options, sys).resolvedModule);
                   if (resolvedModule && resolvedModule.resolvedFileName === fileName2) {
                     currentTsPlusTypes = json[moduleName];
                     currentTsPlusFile = moduleName;
@@ -41893,7 +41900,8 @@ ${lanes.join("\n")}
         for (const key of getOwnKeys(exports)) {
           if (key === "default" || conditions.indexOf(key) >= 0 || isApplicableVersionedTypesKey(conditions, key)) {
             const subTarget = exports[key];
-            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions);
+            const mode2 = typeof subTarget === "string" ? endsWith(subTarget, "/") ? 1 : stringContains(subTarget, "*") ? 2 /* Pattern */ : 0 /* Exact */ : 0 /* Exact */;
+            const result = tryGetModuleNameFromExports(options, targetFilePath, packageDirectory, packageName, subTarget, conditions, mode2);
             if (result) {
               return result;
             }
@@ -41965,7 +41973,7 @@ ${lanes.join("\n")}
     if (!(startsWith(sourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
       return void 0;
     }
-    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+    const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1).replace(/\.pnpm\/[^\/]+\/node_modules\//, "");
     const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
     return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
     function tryDirectoryWithPackageJson(packageRootIndex) {
@@ -47712,6 +47720,16 @@ ${lanes.join("\n")}
         }
         return top;
       }
+      function getSpecifierForModuleSymbolSpecial(symbol, context, overrideImportMode) {
+        let specifier = getSpecifierForModuleSymbol(symbol, context, overrideImportMode);
+        if (specifier && specifier.indexOf("/node_modules/") > 0) {
+          const r = tryGetImportLocation(fileMap.map, specifier);
+          if (r) {
+            specifier = r;
+          }
+        }
+        return specifier;
+      }
       function getSpecifierForModuleSymbol(symbol, context, overrideImportMode) {
         var _a2;
         let file = getDeclarationOfKind(symbol, 308 /* SourceFile */);
@@ -47786,7 +47804,7 @@ ${lanes.join("\n")}
           let assertion;
           if (getEmitModuleResolutionKind(compilerOptions) === 3 /* Node16 */ || getEmitModuleResolutionKind(compilerOptions) === 99 /* NodeNext */) {
             if ((targetFile == null ? void 0 : targetFile.impliedNodeFormat) === 99 /* ESNext */ && targetFile.impliedNodeFormat !== (contextFile == null ? void 0 : contextFile.impliedNodeFormat)) {
-              specifier = getSpecifierForModuleSymbol(chain[0], context, 99 /* ESNext */);
+              specifier = getSpecifierForModuleSymbolSpecial(chain[0], context, 99 /* ESNext */);
               assertion = factory.createImportTypeAssertionContainer(factory.createAssertClause(factory.createNodeArray([
                 factory.createAssertEntry(
                   factory.createStringLiteral("resolution-mode"),
@@ -47797,7 +47815,7 @@ ${lanes.join("\n")}
             }
           }
           if (!specifier) {
-            specifier = getSpecifierForModuleSymbol(chain[0], context);
+            specifier = getSpecifierForModuleSymbolSpecial(chain[0], context);
           }
           if (!(context.flags & 67108864 /* AllowNodeModulesRelativePaths */) && getEmitModuleResolutionKind(compilerOptions) !== 1 /* Classic */ && specifier.indexOf("/node_modules/") >= 0) {
             const oldSpecifier = specifier;
@@ -83167,13 +83185,26 @@ ${lanes.join("\n")}
     node = getOriginalNode(node);
     return node ? getNodeId(node) : 0;
   }
-  function getImportLocation(fileMap, source) {
+  function tryGetImportLocation(fileMap, source) {
+    if (source in importLocationCache) {
+      return importLocationCache[source];
+    }
     for (const [path, reg] of fileMap) {
       if (source.match(reg)) {
-        return source.replace(reg, path);
+        const r = source.replace(reg, path);
+        importLocationCache[source] = r;
+        return r;
       }
     }
-    throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    importLocationCache[source] = void 0;
+    return void 0;
+  }
+  function getImportLocation(fileMap, source) {
+    const found = tryGetImportLocation(fileMap, source);
+    if (!found) {
+      throw new Error(`cannot get import path for file: ${source} (Make sure to add it in your tsplus.config.json)`);
+    }
+    return found;
   }
   function getTraceLocation(traceMap, source) {
     for (const [path, reg] of traceMap) {
@@ -83582,10 +83613,12 @@ ${lanes.join("\n")}
     }
     return { decorators };
   }
+  var importLocationCache;
   var init_utilities3 = __esm({
     "src/compiler/transformers/utilities.ts"() {
       "use strict";
       init_ts2();
+      importLocationCache = {};
     }
   });
 
@@ -159503,6 +159536,7 @@ ${options.prefix}` : "\n" : options.prefix
     tryGetDirectories: () => tryGetDirectories,
     tryGetExtensionFromPath: () => tryGetExtensionFromPath2,
     tryGetImportFromModuleSpecifier: () => tryGetImportFromModuleSpecifier,
+    tryGetImportLocation: () => tryGetImportLocation,
     tryGetModuleNameFromFile: () => tryGetModuleNameFromFile,
     tryGetModuleSpecifierFromDeclaration: () => tryGetModuleSpecifierFromDeclaration,
     tryGetNativePerformanceHooks: () => tryGetNativePerformanceHooks,
